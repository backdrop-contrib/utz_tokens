<?php
/**
 * @file
 * Create tokens to render a date and/or time in the user's time zone.
 */

/**
 * Implements hook_token_info().
 */
function time_tokens_token_info() {
  $info['types']['time-tokens'] = array(
    'name' => t('Time tokens'),
    'description' => t("Tokens that render a date and/or time in the user's time zone."),
  );

  $info['tokens']['time-tokens']['?|?'] = array(
    'name' => t('Date/time'),
    'description' => t("Render a date and/or time in the user's own time zone with a specified format."),
  );
  return $info;
}


/**
 * Implements hook_tokens().
 */
function time_tokens_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'time-tokens') {
    foreach ($tokens as $key => $token) {
      // Note that we use pipe (|) as second delimiter rather than colon (:)
      // because both the time string and format string likely contain colons
      // and the format string could also contain a pipe. So parse carefully.
      $ppos = strpos($key, '|');
      if ($ppos === FALSE) {
        $replacements[$token] = t('Token error: %token has an invalid time-tokens format.', array('%token' => $token));
      }
      else {
        $timestr = trim(substr($key, 0, $ppos));
        try {
          $datetime = new DateTime($timestr); // could fail
          $datetime->setTimeZone(new DateTimeZone(backdrop_get_user_timezone()));
          $format = filter_xss(substr($key, $ppos + 1));
          $replacements[$token] = $datetime->format($format);
        }
        catch (Exception $e) {
          $replacements[$token] = t('Token error: unable to parse time %timestr in %token.', array('%timestr' => $timestr, '%token' => $token));
        }
      }
    }
  }
  return $replacements;
}
